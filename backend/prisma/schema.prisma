generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


// UTILISATEUR //

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  password      String
  firstName     String
  lastName      String
  phone         String?
  role          UserRole  @default(MEMBER)
  
  emailVerified Boolean   @default(false)
  
  subscriptions    Subscription[]
  shiftVolunteers  ShiftVolunteer[]
  newsletters      Newsletter[]
  recipes          Recipe[]
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  deletedAt     DateTime?
  
  @@index([email])
  @@index([role])
}

enum UserRole {
  MEMBER      // Adhérent simple
  VOLUNTEER   // Bénévole (+ accès permanences)
  ADMIN       // Administrateur
}

// DEMANDES D'ABONNEMENTS

model SubscriptionRequest {
  id            String   @id @default(uuid())
  
  firstName     String
  lastName      String
  email         String
  phone         String
  
  type          SubscriptionType
  basketSize    BasketSize
  pricingType   PricingType  @default(NORMAL)
  
  message       String?  @db.Text
  
  status        RequestStatus @default(PENDING)
  adminNotes    String?  @db.Text
  processedAt   DateTime?
  processedBy   String?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([status])
  @@index([email])
  @@index([createdAt])
}

enum RequestStatus {
  PENDING       // En attente de traitement
  IN_PROGRESS   // En cours de traitement
  APPROVED      // Approuvé → abonnement créé
  REJECTED      // Refusé
  ARCHIVED      // Archivé
}


// PRODUCTEUR //

model Producer {
  id          String   @id @default(uuid())
  name        String
  email       String   @unique
  phone       String?
  specialty   String?
  description String?  @db.Text
  image       String?
  isActive    Boolean  @default(true)
  isExample   Boolean  @default(false)
  
  products    Product[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([email])
  @@index([isActive])
}


// PRODUITS //

model Product {
  id          String      @id @default(uuid())
  name        String
  producerId  String
  unit        ProductUnit
  category    ProductCategory?
  description String?     @db.Text
  image       String?
  stock       Float?      @default(0)
  isActive    Boolean     @default(true)
  isExample   Boolean     @default(false)
  
  producer    Producer    @relation(fields: [producerId], references: [id])
  
  weeklyBasketItems WeeklyBasketItem[]
  recipeProducts    RecipeProduct[]
  
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  deletedAt   DateTime?
  
  @@index([producerId])
  @@index([category])
  @@index([isActive])
}

enum ProductUnit {
  KG      // Kilogramme
  PIECE   // Pièce
}

enum ProductCategory {
  VEGETABLES  // Légumes
  FRUITS      // Fruits
  EGGS        // Œufs
  GROCERY     // Épicerie (farine, pâtes, huile, lentilles)
}


// POINT DE RETRAIT //

model PickupLocation {
  id          String   @id @default(uuid())
  name        String
  address     String
  city        String
  postalCode  String
  
  schedule    String   @default("Mercredi 18h15 - 19h15")
  instructions String? @db.Text
  
  isActive    Boolean  @default(true)
  isExample   Boolean  @default(false)
  
  subscriptions Subscription[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}


// ABONNEMENTS //

model Subscription {
  id              String   @id @default(uuid())
  userId          String
  subscriptionNumber String @unique
  
  type            SubscriptionType
  basketSize      BasketSize
  pricingType     PricingType
  status          SubscriptionStatus @default(PENDING)
  
  startDate       DateTime
  endDate         DateTime
  
  price           Float
  paidAmount      Float    @default(0)
  
  pickupLocationId String
  
  user            User            @relation(fields: [userId], references: [id])
  pickupLocation  PickupLocation  @relation(fields: [pickupLocationId], references: [id])
  
  pickups         WeeklyPickup[]
  pauses          SubscriptionPause[]
  payments        Payment[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([userId])
  @@index([status])
  @@index([type])
  @@index([pricingType])
}

enum SubscriptionType {
  ANNUAL      // Annuel (janvier → décembre)
  DISCOVERY   // Découverte (3 mois)
}

enum BasketSize {
  SMALL   // Petit panier (2-4 kg)
  LARGE   // Grand panier (6-8 kg)
}

enum PricingType {
  NORMAL      // Tarif normal (100%)
  SOLIDARITY  // Tarif solidaire (20% adhérent + 80% Secours Catholique)
}

enum SubscriptionStatus {
  PENDING     // En attente de paiement
  ACTIVE      // Actif
  PAUSED      // En pause
  EXPIRED     // Expiré
  CANCELLED   // Annulé
}


// PAUSES D'ABONNEMENT //

model SubscriptionPause {
  id              String   @id @default(uuid())
  subscriptionId  String
  startDate       DateTime
  endDate         DateTime
  reason          String?
  
  subscription    Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime @default(now())
  
  @@index([subscriptionId])
}


// PAIEMENTS //

model Payment {
  id                String   @id @default(uuid())
  subscriptionId    String
  amount            Float
  status            PaymentStatus @default(PENDING)
  
  stripePaymentId   String?  @unique
  paymentMethod     String?
  
  subscription      Subscription @relation(fields: [subscriptionId], references: [id])
  
  createdAt         DateTime @default(now())
  paidAt            DateTime?
  
  @@index([subscriptionId])
  @@index([status])
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  REFUNDED
}


// PANIER HEBDOMADAIRE //

model WeeklyBasket {
  id              String   @id @default(uuid())
  weekNumber      Int
  year            Int
  distributionDate DateTime
  
  isPublished     Boolean  @default(false)
  publishedAt     DateTime?
  
  notes           String?  @db.Text
  
  items           WeeklyBasketItem[]
  pickups         WeeklyPickup[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@unique([year, weekNumber])
  @@index([distributionDate])
  @@index([isPublished])
}

model WeeklyBasketItem {
  id              String   @id @default(uuid())
  weeklyBasketId  String
  productId       String
  
  quantitySmall   Float
  quantityLarge   Float
  
  weeklyBasket    WeeklyBasket @relation(fields: [weeklyBasketId], references: [id], onDelete: Cascade)
  product         Product      @relation(fields: [productId], references: [id], onDelete: Cascade)
  
  @@unique([weeklyBasketId, productId])
  @@index([productId])
}


// RETRAITS EFFECTUÉS //

model WeeklyPickup {
  id              String   @id @default(uuid())
  subscriptionId  String
  weeklyBasketId  String
  pickupDate      DateTime
  
  wasPickedUp     Boolean  @default(false)
  pickedUpAt      DateTime?
  pickedUpBy      String?
  notes           String?
  
  subscription    Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  weeklyBasket    WeeklyBasket @relation(fields: [weeklyBasketId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime @default(now())
  
  @@unique([subscriptionId, weeklyBasketId])
  @@index([weeklyBasketId])
  @@index([pickupDate])
}


// GESTION DES PERMANENCES //

model Shift {
  id                String   @id @default(uuid())
  distributionDate  DateTime
  startTime         String   @default("18:15")
  endTime           String   @default("19:15")
  volunteersNeeded  Int      @default(2)
  notes             String?  @db.Text
  
  volunteers        ShiftVolunteer[]
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@index([distributionDate])
}

model ShiftVolunteer {
  id        String   @id @default(uuid())
  shiftId   String
  userId    String
  role      String?
  status    VolunteerStatus @default(CONFIRMED)
  
  shift     Shift    @relation(fields: [shiftId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  
  @@unique([shiftId, userId])
  @@index([userId])
}

enum VolunteerStatus {
  CONFIRMED
  CANCELLED
  ABSENT
}


// NEWSLETTER / COMMUNICATION //

model Newsletter {
  id          String   @id @default(uuid())
  subject     String
  content     String   @db.Text
  type        NewsletterType @default(GENERAL)
  target      NewsletterTarget @default(ALL)
  
  scheduledFor DateTime?
  sentAt      DateTime?
  sentCount   Int      @default(0)
  openCount   Int      @default(0)
  
  createdBy   String
  author      User     @relation(fields: [createdBy], references: [id])
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([sentAt])
  @@index([createdBy])
}

enum NewsletterType {
  GENERAL
  WEEKLY_BASKET
  RECIPE
  ALERT
  PRODUCER_NEWS
}

enum NewsletterTarget {
  ALL
  ACTIVE_SUBSCRIBERS
  SOLIDARITY
  TEST
}


// RECETTES DE CUISINE //

model Recipe {
  id          String   @id @default(uuid())
  title       String
  slug        String   @unique
  description String?  @db.Text
  ingredients String   @db.Text
  steps       String   @db.Text
  
  prepTime    Int?
  cookTime    Int?
  servings    Int?
  difficulty  RecipeDifficulty? @default(EASY)
  season      Season?
  
  image       String?
  tips        String?  @db.Text
  
  authorId    String
  author      User     @relation(fields: [authorId], references: [id])
  
  products    RecipeProduct[]
  
  isPublished Boolean  @default(false)
  publishedAt DateTime?
  
  viewCount   Int      @default(0)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([slug])
  @@index([season])
  @@index([isPublished])
}

model RecipeProduct {
  id         String  @id @default(uuid())
  recipeId   String
  productId  String
  quantity   String
  isOptional Boolean @default(false)
  
  recipe     Recipe  @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  product    Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  
  @@index([recipeId])
  @@index([productId])
}

enum RecipeDifficulty {
  EASY
  MEDIUM
  HARD
}

enum Season {
  SPRING
  SUMMER
  AUTUMN
  WINTER
}


// DEMANDES PRODUCTEURS //

model ProducerInquiry {
  id            String   @id @default(uuid())
  
  firstName     String
  lastName      String
  email         String
  phone         String
  
  farmName      String
  address       String
  city          String
  postalCode    String
  distance      Int?
  
  products      String   @db.Text
  isBio         Boolean  @default(false)
  certifications String?  @db.Text
  
  message       String?  @db.Text
  availability  String?
  
  status        InquiryStatus @default(PENDING)
  adminNotes    String?  @db.Text
  respondedAt   DateTime?
  respondedBy   String?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([status])
  @@index([createdAt])
}

enum InquiryStatus {
  PENDING
  IN_PROGRESS
  ACCEPTED
  REJECTED
  ARCHIVED
}


// THÈME SAISONNIER (Existant - conservé) //

model ThemeConfig {
  id              String  @id @default(uuid())
  season          Season  @unique
  primaryColor    String
  secondaryColor  String
  accentColor     String
  backgroundColor String
  backgroundImage String?
  isActive        Boolean @default(false)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}