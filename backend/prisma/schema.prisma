// GESTION DES PERMANENCES //


model Shift {
  id                String   @id @default(uuid())
  distributionDate  DateTime
  startTime         String   @default("18:15")
  endTime           String   @default("19:15")
  volunteersNeeded  Int      @default(2)
  notes             String?  @db.Text
  
  volunteers        ShiftVolunteer[]
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@index([distributionDate])
}

model ShiftVolunteer {
  id        String   @id @default(uuid())
  shiftId   String
  userId    String
  role      String?  // "Préparation", "Distribution", "Accueil"
  status    VolunteerStatus @default(CONFIRMED)
  
  shift     Shift    @relation(fields: [shiftId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  
  @@unique([shiftId, userId])
  @@index([userId])
}

enum VolunteerStatus {
  CONFIRMED   // A confirmé sa présence
  CANCELLED   // S'est désisté
  ABSENT      // Ne s'est pas présenté
}


// NEWSLETTER / COMMUNICATION //

model Newsletter {
  id          String   @id @default(uuid())
  subject     String
  content     String   @db.Text
  type        NewsletterType @default(GENERAL)
  target      NewsletterTarget @default(ALL)
  
  scheduledFor DateTime?
  sentAt      DateTime?
  sentCount   Int      @default(0)
  openCount   Int      @default(0)
  
  createdBy   String
  author      User     @relation(fields: [createdBy], references: [id])
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([sentAt])
  @@index([createdBy])
}

enum NewsletterType {
  GENERAL           // Info générale
  WEEKLY_BASKET     // Panier de la semaine
  RECIPE            // Recette
  ALERT             // Alerte (annulation, changement)
  PRODUCER_NEWS     // Nouvelles des producteurs
}

enum NewsletterTarget {
  ALL                 // Tous les adhérents
  ACTIVE_SUBSCRIBERS  // Abonnements actifs uniquement
  SOLIDARITY          // Tarif solidaire uniquement (discret)
  TEST                // Envoi test (admin uniquement)
}


// RECETTES DE CUISINE //

model Recipe {
  id          String   @id @default(uuid())
  title       String
  slug        String   @unique
  description String?  @db.Text
  ingredients String   @db.Text  // Format texte ou JSON
  steps       String   @db.Text
  
  prepTime    Int?     // minutes
  cookTime    Int?     // minutes
  servings    Int?     // nombre de personnes
  difficulty  RecipeDifficulty? @default(EASY)
  season      Season?
  
  image       String?
  tips        String?  @db.Text  // Astuces de préparation
  
  authorId    String
  author      User     @relation(fields: [authorId], references: [id])
  
  products    RecipeProduct[]
  
  isPublished Boolean  @default(false)
  publishedAt DateTime?
  
  viewCount   Int      @default(0)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([slug])
  @@index([season])
  @@index([isPublished])
}

model RecipeProduct {
  id         String  @id @default(uuid())
  recipeId   String
  productId  String
  quantity   String  // "500g", "2 pièces", "1 bouquet"
  isOptional Boolean @default(false)
  
  recipe     Recipe  @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  product    Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  
  @@index([recipeId])
  @@index([productId])
}

enum RecipeDifficulty {
  EASY      // Facile
  MEDIUM    // Moyen
  HARD      // Difficile
}


// DEMANDES PRODUCTEURS //

model ProducerInquiry {
  id            String   @id @default(uuid())
  
  // Informations contact
  firstName     String
  lastName      String
  email         String
  phone         String
  
  // Informations exploitation
  farmName      String
  address       String
  city          String
  postalCode    String
  distance      Int?     // Distance en km depuis le point de retrait
  
  // Production
  products      String   @db.Text  // Types de produits (légumes, fruits, œufs, etc.)
  isBio         Boolean  @default(false)
  certifications String?  @db.Text  // AB, Nature & Progrès, etc.
  
  // Message
  message       String?  @db.Text
  availability  String?  // Disponibilité pour rencontre
  
  // Suivi
  status        InquiryStatus @default(PENDING)
  adminNotes    String?  @db.Text
  respondedAt   DateTime?
  respondedBy   String?
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([status])
  @@index([createdAt])
}

enum InquiryStatus {
  PENDING       // En attente de traitement
  IN_PROGRESS   // En cours d'évaluation
  ACCEPTED      // Accepté → devient producteur
  REJECTED      // Refusé
  ARCHIVED      // Archivé
}


// ABONNEMENTS (Nouveau modèle) //

model Subscription {
  id              String   @id @default(uuid())
  userId          String
  subscriptionNumber String @unique  // Ex: "SUB-2025-001"
  
  type            SubscriptionType
  basketSize      BasketSize
  pricingType     PricingType
  status          SubscriptionStatus @default(PENDING)
  
  startDate       DateTime
  endDate         DateTime
  
  price           Float
  paidAmount      Float    @default(0)
  
  pickupLocationId String
  
  // Relations
  user            User            @relation(fields: [userId], references: [id])
  pickupLocation  PickupLocation  @relation(fields: [pickupLocationId], references: [id])
  
  pickups         WeeklyPickup[]
  pauses          SubscriptionPause[]
  payments        Payment[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([userId])
  @@index([status])
  @@index([type])
  @@index([pricingType])
}

enum SubscriptionType {
  ANNUAL      // Annuel (janvier → décembre)
  DISCOVERY   // Découverte (3 mois)
}

enum BasketSize {
  SMALL   // Petit panier (2-4 kg)
  LARGE   // Grand panier (6-8 kg)
}

enum PricingType {
  NORMAL      // Tarif normal (100%)
  SOLIDARITY  // Tarif solidaire (20% adhérent + 80% Secours Catholique)
}

enum SubscriptionStatus {
  PENDING     // En attente de paiement
  ACTIVE      // Actif
  PAUSED      // En pause
  EXPIRED     // Expiré
  CANCELLED   // Annulé
}


// PAUSES D'ABONNEMENT //

model SubscriptionPause {
  id              String   @id @default(uuid())
  subscriptionId  String
  startDate       DateTime
  endDate         DateTime
  reason          String?
  
  subscription    Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime @default(now())
  
  @@index([subscriptionId])
}


// PANIER HEBDOMADAIRE //

model WeeklyBasket {
  id              String   @id @default(uuid())
  weekNumber      Int      // Numéro de semaine (1-52)
  year            Int
  distributionDate DateTime
  
  isPublished     Boolean  @default(false)
  publishedAt     DateTime?
  
  notes           String?  @db.Text  // Message de la semaine
  
  items           WeeklyBasketItem[]
  pickups         WeeklyPickup[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@unique([year, weekNumber])
  @@index([distributionDate])
  @@index([isPublished])
}

model WeeklyBasketItem {
  id              String   @id @default(uuid())
  weeklyBasketId  String
  productId       String
  
  quantitySmall   Float    // Quantité pour petit panier
  quantityLarge   Float    // Quantité pour grand panier
  
  weeklyBasket    WeeklyBasket @relation(fields: [weeklyBasketId], references: [id], onDelete: Cascade)
  product         Product      @relation(fields: [productId], references: [id], onDelete: Cascade)
  
  @@unique([weeklyBasketId, productId])
  @@index([productId])
}


// RETRAITS EFFECTUÉS //

model WeeklyPickup {
  id              String   @id @default(uuid())
  subscriptionId  String
  weeklyBasketId  String
  pickupDate      DateTime
  
  wasPickedUp     Boolean  @default(false)
  pickedUpAt      DateTime?
  pickedUpBy      String?  // Nom du bénévole qui a validé
  notes           String?  // Notes (ex: "Récupéré par son voisin")
  
  subscription    Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  weeklyBasket    WeeklyBasket @relation(fields: [weeklyBasketId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime @default(now())
  
  @@unique([subscriptionId, weeklyBasketId])
  @@index([weeklyBasketId])
  @@index([pickupDate])
}


// PRODUITS (Simplifié) //

model Product {
  id          String      @id @default(uuid())
  name        String
  producerId  String
  unit        ProductUnit
  category    ProductCategory?
  description String?     @db.Text
  image       String?
  isActive    Boolean     @default(true)
  
  producer    Producer    @relation(fields: [producerId], references: [id])
  
  weeklyBasketItems WeeklyBasketItem[]
  recipeProducts    RecipeProduct[]
  
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  deletedAt   DateTime?
  
  @@index([producerId])
  @@index([category])
  @@index([isActive])
}

enum ProductUnit {
  KG      // Kilogramme
  PIECE   // Pièce
}

enum ProductCategory {
  VEGETABLES  // Légumes
  FRUITS      // Fruits
  EGGS        // Œufs
  GROCERY     // Épicerie (farine, pâtes, huile, lentilles)
}


// PAIEMENTS //

model Payment {
  id                String   @id @default(uuid())
  subscriptionId    String
  amount            Float
  status            PaymentStatus @default(PENDING)
  
  stripePaymentId   String?  @unique
  paymentMethod     String?  // card, sepa_debit, etc.
  
  subscription      Subscription @relation(fields: [subscriptionId], references: [id])
  
  createdAt         DateTime @default(now())
  paidAt            DateTime?
  
  @@index([subscriptionId])
  @@index([status])
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  REFUNDED
}


// UTILISATEUR (Adapté) //

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  password      String
  firstName     String
  lastName      String
  phone         String?
  role          UserRole  @default(MEMBER)
  
  emailVerified Boolean   @default(false)
  
  subscriptions    Subscription[]
  shiftVolunteers  ShiftVolunteer[]
  newsletters      Newsletter[]
  recipes          Recipe[]
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  deletedAt     DateTime?
  
  @@index([email])
  @@index([role])
}

enum UserRole {
  MEMBER      // Adhérent simple
  VOLUNTEER   // Bénévole (+ accès permanences)
  ADMIN       // Administrateur
}


// POINT DE RETRAIT (Unique) //

model PickupLocation {
  id          String   @id @default(uuid())
  name        String
  address     String
  city        String
  postalCode  String
  
  schedule    String   @default("Mercredi 18h15 - 19h15")
  instructions String? @db.Text  // Indications d'accès
  
  isActive    Boolean  @default(true)
  
  subscriptions Subscription[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}


// PRODUCTEUR (Existant, conservé) //

model Producer {
  id          String   @id @default(uuid())
  name        String
  email       String   @unique
  phone       String?
  specialty   String?
  description String?  @db.Text
  image       String?
  isActive    Boolean  @default(true)
  
  products    Product[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([email])
}